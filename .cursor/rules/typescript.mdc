---
description: TypeScript code style and optimization guidelines
globs: ["*.ts", "*.tsx", "*.mts"]
alwaysApply: false
---

# TypeScript Code Style Guide

## Types and Type Safety

- Avoid explicit type annotations when TypeScript can infer types
- Avoid implicitly `any` variables; explicitly type when necessary (e.g., `let a: number` instead of `let a`)
- Use the most accurate type possible (e.g., prefer `Record<PropertyKey, unknown>` over `object` and `any`)
- Prefer `interface` over `type` for object shapes (e.g., React component props). Keep `type` for unions, intersections, and utility types
- Prefer `as const satisfies XyzInterface` over plain `as const` when suitable
- Prefer `@ts-expect-error` over `@ts-ignore` over `as any`
- Avoid meaningless null/undefined parameters; design strict function contracts

## Asynchronous Patterns and Concurrency

- Prefer `async`/`await` over callbacks or chained `.then` promises
- Prefer async APIs over sync ones (avoid `*Sync`)
- Prefer promise-based variants (e.g., `import { readFile } from 'fs/promises'`) over callback-based APIs from `fs`
- Where safe, convert sequential async flows to concurrent ones with `Promise.all`, `Promise.race`, etc.

## Code Structure and Readability

- Prefer object destructuring when accessing and using properties
- Use consistent, descriptive naming; avoid obscure abbreviations
- Use semantically meaningful variable, function, and class names
- Replace magic numbers or strings with well-named constants
- Defer formatting to tooling; ignore purely formatting-only issues and autofixable lint problems

## UI and Components

- Use components from `@ryla/ui`, Radix UI, or existing design system components instead of raw HTML tags (e.g., `Button` vs. `button`)
- Design for dark mode and mobile responsiveness:
  - Use Tailwind CSS classes and design tokens instead of hard-coded colors
  - Select appropriate component variants
- Import from `@ryla/<lib>` aliases for monorepo packages

## Performance

- Prefer `for…of` loops to index-based `for` loops when feasible
- Reuse existing utils inside `libs/shared` or installed npm packages rather than reinventing the wheel
- Query only the required columns from a database rather than selecting entire rows
- Use React Query (TanStack Query) for data fetching and caching

## Time and Consistency

- Instead of calling `Date.now()` multiple times, assign it to a constant once and reuse it to ensure consistency and improve readability

## Logging

- Never log user private information like API keys, passwords, tokens, etc.
- Use appropriate logging levels (console.error for errors, console.warn for warnings)
- In catch blocks, use `console.error` to log error messages
- For debugging, use structured logging with context

## Nx Monorepo Patterns

- Import from `@ryla/<lib>` aliases (e.g., `@ryla/shared`, `@ryla/business`, `@ryla/data`)
- Follow layer dependencies: Apps → Business → Data → DB
- Never skip layers in imports
- Use path mappings defined in `tsconfig.base.json`

## Error Handling

- Use typed error classes from `@ryla/shared` when available
- Handle errors explicitly; avoid silent failures
- Provide meaningful error messages for debugging
- Use try/catch for async operations that can fail
