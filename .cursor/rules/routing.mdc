---
description: Centralized routing patterns and navigation guidelines for Next.js apps
globs: ["apps/web/**", "apps/admin/**", "apps/funnel/**", "apps/landing/**"]
alwaysApply: true
---

# Routing Patterns

RYLA uses a centralized routing system that provides a single source of truth for all application routes. This eliminates hardcoded route strings and ensures type-safe navigation across the codebase.

## Core Principle

NEVER hardcode route strings. Always use the centralized routes configuration.

## Requirements

### Route Definitions

Each app has its own routes configuration:

- Web app: `apps/web/lib/routes.ts`
- Admin app: `apps/admin/lib/routes.ts`
- Funnel app: (if needed, create `apps/funnel/lib/routes.ts`)
- Landing app: (if needed, create `apps/landing/lib/routes.ts`)

### Route Structure

Routes are organized by feature area:

```typescript
export const routes = {
  // Public routes
  home: '/',
  login: '/login',
  
  // Core app routes
  dashboard: '/dashboard',
  studio: '/studio',
  
  // Dynamic routes
  influencer: {
    detail: (id: string) => `/influencer/${id}`,
  },
  
  // Wizard routes
  wizard: {
    root: '/wizard',
    step0: '/wizard/step-0',
    step: (stepNumber: number) => `/wizard/step-${stepNumber}`,
  },
} as const;
```

### Usage Patterns

#### Static Routes

```tsx
// ✅ Good: Using centralized routes
import { routes } from '@/lib/routes';
import Link from 'next/link';

<Link href={routes.dashboard}>Dashboard</Link>
router.push(routes.studio);
```

#### Dynamic Routes

```tsx
// ✅ Good: Using route builders
import { routes } from '@/lib/routes';

router.push(routes.influencer.detail('123'));
router.push(routes.wizard.step(5));
```

#### Routes with Query Parameters

```tsx
// ✅ Good: Using buildRoute helper
import { routes, buildRoute } from '@/lib/routes';

const url = buildRoute(routes.studio, {
  influencer: '123',
  imageId: '456'
});
// => '/studio?influencer=123&imageId=456'

<Link href={url}>View in Studio</Link>
```

#### Navigation Helper Hook

```tsx
// ✅ Good: Using type-safe navigation hook
import { useNavigate } from '@/lib/navigation';

function MyComponent() {
  const navigate = useNavigate();
  
  navigate.toDashboard();
  navigate.toStudio({ influencer: '123' });
  navigate.toInfluencer.detail('123');
  navigate.toWizard.step(5);
}
```

### Anti-Patterns

```tsx
// ❌ Bad: Hardcoded route strings
<Link href="/dashboard">Dashboard</Link>
router.push('/studio?influencer=123');

// ❌ Bad: Hardcoded in arrays
const PUBLIC_ROUTES = ['/login', '/register'];

// ❌ Bad: String concatenation for routes
router.push(`/wizard/step-${stepNumber}`);
```

### Adding New Routes

1. **Add route to routes.ts**:
   ```typescript
   export const routes = {
     // ... existing routes
     myNewFeature: '/my-new-feature',
   };
   ```

2. **Update public routes if needed**:
   ```typescript
   export const publicRoutes = [
     // ... existing routes
     routes.myNewFeature,
   ];
   ```

3. **Add navigation helper** (optional):
   ```typescript
   // In navigation.ts
   toMyNewFeature = () => this.router.push(routes.myNewFeature);
   ```

4. **Use the route everywhere**:
   ```tsx
   import { routes } from '@/lib/routes';
   <Link href={routes.myNewFeature}>New Feature</Link>
   ```

### Route Matching

```tsx
// ✅ Good: Using matchesRoute helper
import { routes, matchesRoute } from '@/lib/routes';

const isActive = matchesRoute(pathname, routes.studio);
```

### Public Route Checks

```tsx
// ✅ Good: Using isPublicRoute helper
import { isPublicRoute } from '@/lib/routes';

if (isPublicRoute(pathname)) {
  // Route doesn't require authentication
}
```

## File Locations

### Web App
- Routes: `apps/web/lib/routes.ts`
- Navigation: `apps/web/lib/navigation.ts`
- Documentation: `apps/web/lib/ROUTING.md`

### Admin App
- Routes: `apps/admin/lib/routes.ts`
- Navigation: `apps/admin/lib/navigation.ts`

## Migration Checklist

When migrating existing code:

1. ✅ Import routes from centralized config
2. ✅ Replace hardcoded strings with `routes.*`
3. ✅ Use `buildRoute()` for query parameters
4. ✅ Update navigation helpers if needed
5. ✅ Remove unused route string constants
6. ✅ Verify all routes are migrated (grep for `href="/` and `router.push("/`)

## Best Practices

1. **Always use routes object** - Never hardcode route strings
2. **Use buildRoute for query params** - Keeps query building consistent
3. **Use navigation helpers** - Provides better autocomplete and type safety
4. **Update publicRoutes** - When adding new public routes
5. **Document complex routes** - Add JSDoc comments for dynamic routes
6. **Keep routes organized** - Group by feature area
7. **Use TypeScript** - Leverage type safety for route correctness

## Related Documentation

- Web App Routing Guide: `apps/web/lib/ROUTING.md`
- React Patterns: `react-patterns.mdc` (for component patterns)
- File Organization: `file-organization.mdc` (for file structure)
