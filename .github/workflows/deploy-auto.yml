name: Auto Deploy (Nx Affected)

on:
  push:
    branches: [main, staging]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: false
        type: choice
        options:
          - staging
          - production
      force_deploy_landing:
        description: 'Force deploy landing app (even if no landing changes)'
        required: false
        type: boolean
        default: false

permissions:
  contents: read
  pull-requests: read
  deployments: write
  statuses: write

jobs:
  detect-environment:
    name: Detect Environment
    runs-on: ubuntu-latest
    outputs:
      infisical_env: ${{ steps.env.outputs.infisical_env }}
      fly_suffix: ${{ steps.env.outputs.fly_suffix }}
      github_env: ${{ steps.env.outputs.github_env }}
    steps:
      - name: Determine Environment
        id: env
        run: |
          # Determine environment from input, branch, or default to production
          if [ -n "${{ github.event.inputs.environment }}" ]; then
            GITHUB_ENV="${{ github.event.inputs.environment }}"
          elif [ "${{ github.ref }}" == "refs/heads/staging" ]; then
            GITHUB_ENV="staging"
          elif [ "${{ github.ref }}" == "refs/heads/main" ]; then
            GITHUB_ENV="production"
          else
            GITHUB_ENV="production"
          fi

          # Map GitHub environment to Infisical environment
          if [ "$GITHUB_ENV" == "production" ]; then
            echo "infisical_env=prod" >> $GITHUB_OUTPUT
            echo "fly_suffix=prod" >> $GITHUB_OUTPUT
            echo "github_env=production" >> $GITHUB_OUTPUT
          elif [ "$GITHUB_ENV" == "staging" ]; then
            echo "infisical_env=staging" >> $GITHUB_OUTPUT
            echo "fly_suffix=staging" >> $GITHUB_OUTPUT
            echo "github_env=staging" >> $GITHUB_OUTPUT
          else
            echo "infisical_env=dev" >> $GITHUB_OUTPUT
            echo "fly_suffix=dev" >> $GITHUB_OUTPUT
            echo "github_env=development" >> $GITHUB_OUTPUT
          fi

          echo "‚úÖ Environment determined:"
          echo "  GitHub Environment: $GITHUB_ENV"
          echo "  Infisical Environment: $(cat $GITHUB_OUTPUT | grep infisical_env | cut -d'=' -f2)"
          echo "  Fly.io Suffix: $(cat $GITHUB_OUTPUT | grep fly_suffix | cut -d'=' -f2)"

  detect-changes:
    name: Detect Changed Apps
    runs-on: ubuntu-latest
    outputs:
      web: ${{ steps.affected.outputs.web }}
      api: ${{ steps.affected.outputs.api }}
      funnel: ${{ steps.affected.outputs.funnel }}
      landing: ${{ steps.affected.outputs.landing }}
      admin: ${{ steps.affected.outputs.admin }}
      nellab: ${{ steps.affected.outputs.nellab }}
      metabase: ${{ steps.affected.outputs.metabase }}
      has-changes: ${{ steps.affected.outputs.has-changes }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Need full history for Nx affected
          token: ${{ secrets.GITHUB_TOKEN }}
          lfs: false # Not needed for change detection (only checks file paths)
          persist-credentials: true

      - name: Detect affected apps (using git diff)
        id: affected
        run: |
          set +e  # Don't exit on first failure; we have fallbacks
          # Ensure we have origin refs for fallbacks
          git fetch origin main --depth=1 2>/dev/null || true

          # Get base commit (previous commit on main, or main branch if first commit)
          # For push events, use github.event.before if available, otherwise HEAD~1
          if [ "${{ github.event_name }}" = "push" ]; then
            # Use github.event.before if it exists and is valid, otherwise use HEAD~1
            if [ -n "${{ github.event.before }}" ] && [ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]; then
              BASE="${{ github.event.before }}"
              echo "Using github.event.before as base: $BASE"
            else
              # Try HEAD~1, fallback to origin/main
              BASE=$(git rev-parse HEAD~1 2>/dev/null || echo "origin/main")
            fi
            HEAD=$(git rev-parse HEAD 2>/dev/null || echo "HEAD")
          else
            git fetch origin main 2>/dev/null || true
            BASE=$(git merge-base HEAD origin/main 2>/dev/null || echo "origin/main")
            HEAD=$(git rev-parse HEAD 2>/dev/null || echo "HEAD")
          fi
          # Resolve to full SHAs so build-affected and Nx never see invalid refs (avoids git 128)
          BASE=$(git rev-parse "$BASE" 2>/dev/null || git rev-parse HEAD~1 2>/dev/null || echo "HEAD")
          HEAD=$(git rev-parse "$HEAD" 2>/dev/null || echo "HEAD")

          echo "Base: $BASE"
          echo "Head: $HEAD"

          # Use git diff to detect changes in app directories (faster than Nx, no dependencies needed)
          # If diff fails (e.g. invalid refs), treat as no changed files; deploy jobs will be skipped unless forced
          CHANGED_FILES=$(git diff --name-only "$BASE".."$HEAD" 2>/dev/null || echo "")

          echo "Changed files detected: $(echo "$CHANGED_FILES" | wc -l | tr -d ' ') files"

          # Check which apps have changes
          WEB_CHANGED=false
          API_CHANGED=false
          FUNNEL_CHANGED=false
          LANDING_CHANGED=false
          ADMIN_CHANGED=false

          if echo "$CHANGED_FILES" | grep -qE "^apps/web/"; then
            WEB_CHANGED=true
            echo "‚úì Web app has changes"
          fi

          if echo "$CHANGED_FILES" | grep -qE "^apps/api/"; then
            API_CHANGED=true
            echo "‚úì API app has changes"
          fi

          if echo "$CHANGED_FILES" | grep -qE "^apps/funnel/"; then
            FUNNEL_CHANGED=true
            echo "‚úì Funnel app has changes"
          fi

          if echo "$CHANGED_FILES" | grep -qE "^apps/landing/"; then
            LANDING_CHANGED=true
            echo "‚úì Landing app has changes"
          fi

          if echo "$CHANGED_FILES" | grep -qE "^apps/admin/"; then
            ADMIN_CHANGED=true
            echo "‚úì Admin app has changes"
          fi

          NELLAB_CHANGED=false
          if echo "$CHANGED_FILES" | grep -qE "^apps/nellab/"; then
            NELLAB_CHANGED=true
            echo "‚úì Nellab app has changes"
          fi

          METABASE_CHANGED=false
          if echo "$CHANGED_FILES" | grep -qE "^apps/metabase/|^scripts/setup/(metabase|setup-metabase)"; then
            METABASE_CHANGED=true
            echo "‚úì Metabase app or dashboard script has changes"
          fi

          # workflow_dispatch: allow forcing landing deploy without file changes
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.force_deploy_landing }}" = "true" ]; then
            LANDING_CHANGED=true
            echo "‚úì Landing deploy forced via workflow input"
          fi

          # Also check if workflow files changed (affects all apps)
          if echo "$CHANGED_FILES" | grep -qE "^\\.github/workflows/"; then
            echo "‚ö†Ô∏è  Workflow files changed - this may affect all apps"
          fi

          # Set outputs
          echo "web=$WEB_CHANGED" >> $GITHUB_OUTPUT
          echo "api=$API_CHANGED" >> $GITHUB_OUTPUT
          echo "funnel=$FUNNEL_CHANGED" >> $GITHUB_OUTPUT
          echo "landing=$LANDING_CHANGED" >> $GITHUB_OUTPUT
          echo "admin=$ADMIN_CHANGED" >> $GITHUB_OUTPUT
          echo "nellab=$NELLAB_CHANGED" >> $GITHUB_OUTPUT
          echo "metabase=$METABASE_CHANGED" >> $GITHUB_OUTPUT

          if [ "$WEB_CHANGED" = "true" ] || [ "$API_CHANGED" = "true" ] || [ "$FUNNEL_CHANGED" = "true" ] || [ "$LANDING_CHANGED" = "true" ] || [ "$ADMIN_CHANGED" = "true" ] || [ "$NELLAB_CHANGED" = "true" ] || [ "$METABASE_CHANGED" = "true" ]; then
            echo "has-changes=true" >> $GITHUB_OUTPUT
            echo "App changes detected"
          else
            echo "has-changes=false" >> $GITHUB_OUTPUT
            echo "No app changes detected"
          fi

  deploy-web:
    name: Deploy Web App (Fly.io)
    needs: [detect-environment, detect-changes]
    if: needs.detect-changes.outputs.web == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.detect-environment.outputs.github_env }}
    concurrency:
      group: deploy-web-${{ github.ref }}
      cancel-in-progress: true
    steps:
      - uses: actions/checkout@v4
        with:
          lfs: false

      - name: Try to fetch LFS files (optional)
        continue-on-error: true
        run: |
          echo "Attempting to fetch Git LFS files..."
          git lfs install || echo "‚ö†Ô∏è Git LFS install failed"
          git lfs pull 2>&1 || echo "‚ö†Ô∏è Git LFS pull failed (quota exceeded or other error)"
          echo "Continuing with deployment..."

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Enable corepack (for pnpm)
        run: |
          corepack enable
          corepack prepare pnpm@10.26.1 --activate
          echo "pnpm version: $(pnpm --version)"

      - name: Install dependencies (optional - Docker handles deps)
        timeout-minutes: 15
        continue-on-error: true
        run: |
          set +e
          echo "Installing dependencies..."
          pnpm config set store-dir ~/.pnpm-store || true
          pnpm config set network-timeout 180000 || true
          rm -rf ~/.pnpm-store || true
          pnpm install --network-timeout=180000 --reporter=append-only 2>&1 | tee /tmp/pnpm-install.log
          INSTALL_STATUS=${PIPESTATUS[0]}
          if [ $INSTALL_STATUS -ne 0 ]; then
            echo "‚ö†Ô∏è  pnpm install failed, Docker will handle dependencies"
            exit 0
          fi
          echo "‚úÖ Dependencies installed successfully"

      - name: Verify images from Git LFS (optional)
        continue-on-error: true
        run: |
          echo "Checking image directories:"
          if [ -d "./apps/web/public/images" ]; then
            echo "‚úÖ Found apps/web/public/images/"
            echo "Age range images: $(find ./apps/web/public/images/age-ranges -name "*.webp" 2>/dev/null | wc -l | tr -d ' ') files"
            echo "Skin color images: $(find ./apps/web/public/images/skin-colors -name "*.webp" 2>/dev/null | wc -l | tr -d ' ') files"
          else
            echo "‚ö†Ô∏è WARNING: apps/web/public/images/ not found (LFS quota may have been exceeded)"
          fi

      - name: Setup Fly.io CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Install Infisical CLI
        run: |
          curl -1sLf 'https://dl.cloudsmith.io/public/infisical/infisical-cli/setup.deb.sh' | sudo -E bash
          sudo apt-get install infisical

      - name: Export Build Args from Infisical
        id: build-args
        env:
          INFISICAL_TOKEN: ${{ secrets.INFISICAL_TOKEN }}
          # GitHub secrets as fallback
          GH_NEXT_PUBLIC_API_URL: ${{ secrets.NEXT_PUBLIC_API_URL }}
          GH_NEXT_PUBLIC_SITE_URL: ${{ secrets.NEXT_PUBLIC_SITE_URL }}
          GH_NEXT_PUBLIC_CDN_URL: ${{ secrets.NEXT_PUBLIC_CDN_URL }}
          GH_NEXT_PUBLIC_POSTHOG_KEY: ${{ secrets.NEXT_PUBLIC_POSTHOG_KEY }}
          GH_NEXT_PUBLIC_POSTHOG_HOST: ${{ secrets.NEXT_PUBLIC_POSTHOG_HOST }}
          GH_NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          GH_NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}
        run: |
          echo "üì¶ Exporting build args from Infisical (${{ needs.detect-environment.outputs.infisical_env }})..."

          # Try Infisical export, capture stderr for debugging
          if infisical export \
            --domain=https://eu.infisical.com/api \
            --path=/apps/web \
            --path=/shared \
            --env=${{ needs.detect-environment.outputs.infisical_env }} \
            --format=dotenv 2>/tmp/infisical-err.log | grep -E '^[A-Z_]+=.*' > /tmp/build-args.env; then
            echo "‚úÖ Infisical export succeeded"
          else
            echo "‚ö†Ô∏è  Infisical export failed or returned empty"
            cat /tmp/infisical-err.log || true
          fi

          if [ -s /tmp/build-args.env ]; then
            echo "Found $(wc -l < /tmp/build-args.env) secrets from Infisical"
            set -a
            source /tmp/build-args.env
            set +a
          else
            echo "‚ö†Ô∏è  Infisical returned empty, using GitHub secrets as fallback"
          fi

          # Use Infisical values if available, otherwise fall back to GitHub secrets
          API_URL="${NEXT_PUBLIC_API_URL:-$GH_NEXT_PUBLIC_API_URL}"
          SITE_URL="${NEXT_PUBLIC_SITE_URL:-$GH_NEXT_PUBLIC_SITE_URL}"
          CDN_URL="${NEXT_PUBLIC_CDN_URL:-$GH_NEXT_PUBLIC_CDN_URL}"
          POSTHOG_KEY="${NEXT_PUBLIC_POSTHOG_KEY:-$GH_NEXT_PUBLIC_POSTHOG_KEY}"
          POSTHOG_HOST="${NEXT_PUBLIC_POSTHOG_HOST:-$GH_NEXT_PUBLIC_POSTHOG_HOST}"
          SUPABASE_URL="${NEXT_PUBLIC_SUPABASE_URL:-$GH_NEXT_PUBLIC_SUPABASE_URL}"
          SUPABASE_ANON_KEY="${NEXT_PUBLIC_SUPABASE_ANON_KEY:-$GH_NEXT_PUBLIC_SUPABASE_ANON_KEY}"

          # Set as outputs for use in deployment step
          echo "api_url=$API_URL" >> $GITHUB_OUTPUT
          echo "site_url=$SITE_URL" >> $GITHUB_OUTPUT
          echo "cdn_url=$CDN_URL" >> $GITHUB_OUTPUT
          echo "posthog_key=$POSTHOG_KEY" >> $GITHUB_OUTPUT
          echo "posthog_host=$POSTHOG_HOST" >> $GITHUB_OUTPUT
          echo "supabase_url=$SUPABASE_URL" >> $GITHUB_OUTPUT
          echo "supabase_anon_key=$SUPABASE_ANON_KEY" >> $GITHUB_OUTPUT

          echo "‚úÖ Build args exported"
          echo "  NEXT_PUBLIC_API_URL: $API_URL"
          echo "  NEXT_PUBLIC_SITE_URL: $SITE_URL"
          echo "  NEXT_PUBLIC_CDN_URL: $CDN_URL"

          # Verify critical values are set
          if [ -z "$API_URL" ]; then
            echo "‚ùå ERROR: NEXT_PUBLIC_API_URL is empty!"
            exit 1
          fi

      - name: Stop old machines (if any)
        run: |
          sudo apt-get update && sudo apt-get install -y jq || true
          MACHINES=$(flyctl machines list --app ryla-web-${{ needs.detect-environment.outputs.fly_suffix }} --json 2>/dev/null || echo "[]")
          echo "$MACHINES" | jq -r '.[].id' | while read machine_id; do
            if [ -n "$machine_id" ]; then
              echo "Stopping machine: $machine_id"
              flyctl machines stop "$machine_id" --app ryla-web-${{ needs.detect-environment.outputs.fly_suffix }} || true
            fi
          done
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        continue-on-error: true

      - name: Sync Runtime Secrets to Fly.io (via Infisical)
        run: |
          echo "üîÑ Syncing runtime secrets from Infisical to Fly.io..."
          echo "Environment: ${{ needs.detect-environment.outputs.infisical_env }}"

          infisical export \
            --domain=https://eu.infisical.com/api \
            --path=/apps/web \
            --path=/shared \
            --env=${{ needs.detect-environment.outputs.infisical_env }} \
            --format=dotenv | while IFS='=' read -r key value; do
            [[ -z "$key" || "$key" =~ ^# ]] && continue
            [[ "$key" =~ ^NEXT_PUBLIC_ ]] && continue
            value="${value%\"}"
            value="${value#\"}"
            echo "  Setting $key..."
            flyctl secrets set "$key=$value" --app ryla-web-${{ needs.detect-environment.outputs.fly_suffix }} --stage
          done

          flyctl secrets deploy --app ryla-web-${{ needs.detect-environment.outputs.fly_suffix }}
          echo "‚úÖ Secrets synced successfully"
        env:
          INFISICAL_TOKEN: ${{ secrets.INFISICAL_TOKEN }}
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        continue-on-error: true

      - name: Deploy Web App to Fly.io
        run: |
          flyctl deploy \
            --config apps/web/fly.toml \
            --dockerfile apps/web/Dockerfile \
            --app ryla-web-${{ needs.detect-environment.outputs.fly_suffix }} \
            --strategy immediate \
            --build-arg NEXT_PUBLIC_API_URL="${{ steps.build-args.outputs.api_url }}" \
            --build-arg NEXT_PUBLIC_SITE_URL="${{ steps.build-args.outputs.site_url }}" \
            --build-arg NEXT_PUBLIC_CDN_URL="${{ steps.build-args.outputs.cdn_url }}" \
            --build-arg NEXT_PUBLIC_POSTHOG_KEY="${{ steps.build-args.outputs.posthog_key }}" \
            --build-arg NEXT_PUBLIC_POSTHOG_HOST="${{ steps.build-args.outputs.posthog_host }}" \
            --build-arg NEXT_PUBLIC_SUPABASE_URL="${{ steps.build-args.outputs.supabase_url }}" \
            --build-arg NEXT_PUBLIC_SUPABASE_ANON_KEY="${{ steps.build-args.outputs.supabase_anon_key }}"
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}

      - name: Health Check
        run: |
          sleep 10
          flyctl status --app ryla-web-${{ needs.detect-environment.outputs.fly_suffix }}
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}

      - name: Notify Slack
        if: success()
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text":"DEPLOY: ${{ needs.detect-environment.outputs.github_env }} ${{ github.ref_name }} - web app success (Fly.io)"}' \
            ${{ secrets.SLACK_WEBHOOK_DEPLOYS || 'https://hooks.slack.com/services/PLACEHOLDER' }}
        continue-on-error: true

  deploy-api:
    name: Deploy API App
    needs: [detect-environment, detect-changes]
    if: needs.detect-changes.outputs.api == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.detect-environment.outputs.github_env }}
    # Cancel in-progress API app deployments when new commit affects API app
    concurrency:
      group: deploy-api-${{ github.ref }}
      cancel-in-progress: true
    steps:
      - name: Install Git LFS (before checkout)
        run: |
          sudo apt-get update
          sudo apt-get install -y git-lfs
          git lfs install

      - uses: actions/checkout@v4
        with:
          lfs: false # Disable LFS in checkout, we'll handle it manually
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Configure Git LFS and pull files
        run: |
          set +e  # Don't fail job on LFS/git errors; deployment doesn't require LFS
          git lfs install 2>/dev/null || echo "‚ö†Ô∏è  Git LFS install failed, continuing..."
          git config --global credential.helper store 2>/dev/null || true
          echo "https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com" > ~/.git-credentials 2>/dev/null || true
          git lfs pull 2>&1 || echo "‚ö†Ô∏è  Git LFS pull failed, continuing without LFS files..."
          echo "‚úÖ Git LFS configuration complete (or skipped)"
          exit 0  # Always succeed so deploy continues

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Enable corepack (for pnpm)
        run: |
          corepack enable
          corepack prepare pnpm@10.26.1 --activate
          echo "pnpm version: $(pnpm --version)"

      - name: Install dependencies (optional - Docker handles deps)
        timeout-minutes: 15
        continue-on-error: true
        run: |
          set +e  # Don't exit on error, we'll handle it manually

          echo "Installing dependencies..."
          echo "pnpm version: $(pnpm --version || echo 'not found')"
          echo "Node version: $(node --version || echo 'not found')"
          echo "Working directory: $(pwd)"
          echo "Checking lockfile..."
          ls -la pnpm-lock.yaml || echo "‚ö†Ô∏è  pnpm-lock.yaml not found"

          # Set pnpm config for CI
          pnpm config set store-dir ~/.pnpm-store || true
          pnpm config set network-timeout 180000 || true
          pnpm config set fetch-retries 5 || true
          pnpm config set fetch-retry-mintimeout 10000 || true
          pnpm config set fetch-retry-maxtimeout 60000 || true

          # Clear pnpm store cache if it exists (might be corrupted)
          echo "Clearing pnpm store cache..."
          rm -rf ~/.pnpm-store || true

          # Try install - start without --frozen-lockfile for better compatibility
          echo "Running pnpm install (without --frozen-lockfile for CI compatibility)..."
          pnpm install --network-timeout=180000 --reporter=append-only 2>&1 | tee /tmp/pnpm-install.log
          INSTALL_STATUS=${PIPESTATUS[0]}

          if [ $INSTALL_STATUS -ne 0 ]; then
            echo "‚ö†Ô∏è  pnpm install failed (exit code: $INSTALL_STATUS)"
            echo "Last 100 lines of pnpm install log:"
            tail -100 /tmp/pnpm-install.log || echo "Could not read log"
            echo "Trying with --frozen-lockfile..."
            pnpm install --frozen-lockfile --network-timeout=180000 --reporter=append-only 2>&1 | tee /tmp/pnpm-install-frozen.log
            INSTALL_STATUS=${PIPESTATUS[0]}
            
            if [ $INSTALL_STATUS -ne 0 ]; then
              echo "‚ùå pnpm install failed completely (exit code: $INSTALL_STATUS)"
              echo "Last 100 lines of frozen lockfile log:"
              tail -100 /tmp/pnpm-install-frozen.log || echo "Could not read frozen log"
              echo "Checking pnpm and node versions..."
              pnpm --version || echo "pnpm not available"
              node --version || echo "node not available"
              echo "Checking if lockfile exists..."
              ls -la pnpm-lock.yaml || echo "Lockfile missing"
              echo "Checking disk space..."
              df -h || echo "Cannot check disk space"
              echo "Checking memory..."
              free -h || echo "Cannot check memory"
              echo "Checking network connectivity..."
              curl -I https://registry.npmjs.org/ || echo "Cannot reach npm registry"
              echo "‚ö†Ô∏è  pnpm install failed, but continuing - Docker build will handle dependencies"
              exit 0  # Don't fail - Docker will install deps
            fi
          fi

          echo "‚úÖ Dependencies installed successfully"

      - name: Setup Fly.io CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Install Infisical CLI
        run: |
          curl -1sLf 'https://dl.cloudsmith.io/public/infisical/infisical-cli/setup.deb.sh' | sudo -E bash
          sudo apt-get install infisical

      - name: Setup Fly.io CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Stop old machines (if any)
        run: |
          # Install jq if not available
          sudo apt-get update && sudo apt-get install -y jq || true
          # Stop all machines for this app to ensure clean deployment
          MACHINES=$(flyctl machines list --app ryla-api-${{ needs.detect-environment.outputs.fly_suffix }} --json 2>/dev/null || echo "[]")
          echo "$MACHINES" | jq -r '.[].id' | while read machine_id; do
            if [ -n "$machine_id" ]; then
              echo "Stopping machine: $machine_id"
              flyctl machines stop "$machine_id" --app ryla-api-${{ needs.detect-environment.outputs.fly_suffix }} || true
            fi
          done
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        continue-on-error: true

      - name: Sync Runtime Secrets to Fly.io (via Infisical)
        run: |
          echo "üîÑ Syncing runtime secrets from Infisical to Fly.io..."
          echo "Environment: ${{ needs.detect-environment.outputs.infisical_env }}"

          # Export secrets from Infisical and set them in Fly.io
          # Note: Also check root path (/) as fallback for staging/prod until folders are created
          infisical export \
            --domain=https://eu.infisical.com/api \
            --path=/apps/api \
            --path=/shared \
            --path=/ \
            --env=${{ needs.detect-environment.outputs.infisical_env }} \
            --format=dotenv | while IFS='=' read -r key value; do
            # Skip empty lines and comments
            [[ -z "$key" || "$key" =~ ^# ]] && continue
            # Remove quotes from value if present
            value="${value%\"}"
            value="${value#\"}"
            echo "  Setting $key..."
            flyctl secrets set "$key=$value" --app ryla-api-${{ needs.detect-environment.outputs.fly_suffix }} --stage
          done

          # Deploy staged secrets
          flyctl secrets deploy --app ryla-api-${{ needs.detect-environment.outputs.fly_suffix }}
          echo "‚úÖ Secrets synced successfully"
        env:
          INFISICAL_TOKEN: ${{ secrets.INFISICAL_TOKEN }}
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        continue-on-error: true

      - name: Deploy API App to Fly.io
        run: |
          flyctl deploy \
            --config apps/api/fly.toml \
            --dockerfile apps/api/Dockerfile \
            --app ryla-api-${{ needs.detect-environment.outputs.fly_suffix }} \
            --strategy immediate
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}

      - name: Health Check
        run: |
          sleep 10
          flyctl status --app ryla-api-${{ needs.detect-environment.outputs.fly_suffix }}
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}

      - name: Notify Slack
        if: success()
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text":"DEPLOY: production ${{ github.ref_name }} - api app success"}' \
            ${{ secrets.SLACK_WEBHOOK_DEPLOYS || 'https://hooks.slack.com/services/PLACEHOLDER' }}
        continue-on-error: true

  # ============================================================================
  # CLOUDFLARE PAGES DEPLOYMENTS
  # Landing and Funnel apps are deployed to Cloudflare Pages for edge performance
  # ============================================================================

  deploy-funnel:
    name: Deploy Funnel App (Cloudflare Pages)
    needs: [detect-environment, detect-changes]
    if: needs.detect-changes.outputs.funnel == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.detect-environment.outputs.github_env }}
    concurrency:
      group: deploy-funnel-${{ github.ref }}
      cancel-in-progress: true
    steps:
      - uses: actions/checkout@v4
        with:
          lfs: false # Funnel app doesn't need LFS files (images)

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Enable corepack (for pnpm)
        run: corepack enable

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Remove API routes for static export
        run: |
          echo "Removing API routes for static export (not supported by Cloudflare Pages)..."
          rm -rf apps/funnel/app/api
          echo "‚úÖ API routes removed"

      - name: Build Funnel App
        run: pnpm nx build funnel --configuration=production
        env:
          CLOUDFLARE_PAGES: 'true'
          NEXT_PUBLIC_CDN_URL: ${{ secrets.NEXT_PUBLIC_CDN_URL }}
          NEXT_PUBLIC_DEBUG_CDN: ${{ secrets.NEXT_PUBLIC_DEBUG_CDN }}
          NEXT_PUBLIC_SITE_URL: ${{ secrets.NEXT_PUBLIC_SITE_URL_FUNNEL }}
          NEXT_PUBLIC_API_BASE_URL: ${{ secrets.NEXT_PUBLIC_API_BASE_URL }}
          NEXT_PUBLIC_FINBY_PAYMENT_REDIRECT: ${{ secrets.NEXT_PUBLIC_FINBY_PAYMENT_REDIRECT }}
          NEXT_PUBLIC_POSTHOG_KEY: ${{ secrets.NEXT_PUBLIC_POSTHOG_KEY }}
          NEXT_PUBLIC_POSTHOG_HOST: ${{ secrets.NEXT_PUBLIC_POSTHOG_HOST }}
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}

      - name: Find and verify static export output
        id: find-output
        run: |
          echo "Looking for static export output..."
          if [ -d "apps/funnel/out" ]; then
            echo "Found apps/funnel/out"
            echo "directory=apps/funnel/out" >> $GITHUB_OUTPUT
          elif [ -d "dist/apps/funnel/out" ]; then
            echo "Found dist/apps/funnel/out"
            echo "directory=dist/apps/funnel/out" >> $GITHUB_OUTPUT
          elif [ -d "dist/apps/funnel" ]; then
            echo "Found dist/apps/funnel"
            echo "directory=dist/apps/funnel" >> $GITHUB_OUTPUT
          else
            echo "‚ùå No static export output found!"
            ls -la apps/funnel/ | head -10
            ls -la dist/ 2>/dev/null | head -10 || echo "dist/ doesn't exist"
            exit 1
          fi

      - name: Deploy to Cloudflare Pages
        uses: cloudflare/pages-action@v1
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          projectName: ryla-funnel
          directory: ${{ steps.find-output.outputs.directory }}
          gitHubToken: ${{ secrets.GITHUB_TOKEN }}

      - name: Notify Slack
        if: success()
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text":"DEPLOY: ${{ needs.detect-environment.outputs.github_env }} ${{ github.ref_name }} - funnel app success (Cloudflare Pages)"}' \
            ${{ secrets.SLACK_WEBHOOK_DEPLOYS || 'https://hooks.slack.com/services/PLACEHOLDER' }}
        continue-on-error: true

  deploy-landing:
    name: Deploy Landing App (Cloudflare Pages)
    needs: [detect-environment, detect-changes]
    if: needs.detect-changes.outputs.landing == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.detect-environment.outputs.github_env }}
    concurrency:
      group: deploy-landing-${{ github.ref }}
      cancel-in-progress: true
    steps:
      - uses: actions/checkout@v4
        with:
          lfs: false # Landing app doesn't need LFS files (images)

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Enable corepack (for pnpm)
        run: |
          corepack enable
          corepack prepare pnpm@10.26.1 --activate
          echo "pnpm version: $(pnpm --version)"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Remove API routes for static export
        run: |
          echo "Removing API routes for static export (not supported by Cloudflare Pages)..."
          rm -rf apps/landing/app/api
          echo "‚úÖ API routes removed"

      - name: Verify CDN secret for landing images
        env:
          NEXT_PUBLIC_CDN_URL: ${{ secrets.NEXT_PUBLIC_CDN_URL }}
        run: |
          if [ -z "$NEXT_PUBLIC_CDN_URL" ]; then
            echo "::error::NEXT_PUBLIC_CDN_URL must be set for landing images to load from CDN. Add it in GitHub: Settings ‚Üí Secrets and variables ‚Üí Actions ‚Üí Repository secrets (use https://cdn.ryla.ai)."
            exit 1
          fi
          echo "‚úÖ NEXT_PUBLIC_CDN_URL is set (landing images will use CDN)"

      - name: Build Landing App
        run: pnpm nx build landing --configuration=production
        env:
          CLOUDFLARE_PAGES: 'true'
          NEXT_PUBLIC_SITE_URL: ${{ secrets.NEXT_PUBLIC_SITE_URL_LANDING }}
          NEXT_PUBLIC_CDN_URL: ${{ secrets.NEXT_PUBLIC_CDN_URL }}
          NEXT_PUBLIC_DEBUG_CDN: ${{ secrets.NEXT_PUBLIC_DEBUG_CDN }}

      - name: Find and verify static export output
        id: find-output
        run: |
          echo "Looking for static export output..."
          if [ -d "apps/landing/out" ]; then
            echo "Found apps/landing/out"
            echo "directory=apps/landing/out" >> $GITHUB_OUTPUT
          elif [ -d "dist/apps/landing/out" ]; then
            echo "Found dist/apps/landing/out"
            echo "directory=dist/apps/landing/out" >> $GITHUB_OUTPUT
          elif [ -f "dist/apps/landing/.next/index.html" ]; then
            echo "Found dist/apps/landing/.next (Nx static export)"
            echo "directory=dist/apps/landing/.next" >> $GITHUB_OUTPUT
          elif [ -d "dist/apps/landing" ]; then
            echo "Found dist/apps/landing (checking for static files)..."
            ls -la dist/apps/landing/ | head -20
            echo "directory=dist/apps/landing" >> $GITHUB_OUTPUT
          else
            echo "‚ùå No static export output found!"
            echo "Checking available directories..."
            ls -la apps/landing/ | head -10
            ls -la dist/ 2>/dev/null | head -10 || echo "dist/ doesn't exist"
            exit 1
          fi

      - name: Deploy to Cloudflare Pages
        uses: cloudflare/pages-action@v1
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          projectName: ryla-landing
          directory: ${{ steps.find-output.outputs.directory }}
          gitHubToken: ${{ secrets.GITHUB_TOKEN }}

      - name: Notify Slack
        if: success()
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text":"DEPLOY: ${{ needs.detect-environment.outputs.github_env }} ${{ github.ref_name }} - landing app success (Cloudflare Pages)"}' \
            ${{ secrets.SLACK_WEBHOOK_DEPLOYS || 'https://hooks.slack.com/services/PLACEHOLDER' }}
        continue-on-error: true

  deploy-nellab:
    name: Deploy Nellab App (Cloudflare Pages)
    needs: [detect-environment, detect-changes]
    if: needs.detect-changes.outputs.nellab == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.detect-environment.outputs.github_env }}
    concurrency:
      group: deploy-nellab-${{ github.ref }}
      cancel-in-progress: true
    steps:
      - uses: actions/checkout@v4
        with:
          lfs: false

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Enable corepack (for pnpm)
        run: |
          corepack enable
          corepack prepare pnpm@10.26.1 --activate
          echo "pnpm version: $(pnpm --version)"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build Nellab App
        run: pnpm nx build nellab --configuration=production
        env:
          CLOUDFLARE_PAGES: 'true'

      - name: Find and verify static export output
        id: find-output
        run: |
          echo "Looking for static export output..."
          if [ -d "dist/apps/nellab/out" ]; then
            echo "Found dist/apps/nellab/out"
            echo "directory=dist/apps/nellab/out" >> $GITHUB_OUTPUT
          elif [ -f "dist/apps/nellab/.next/index.html" ]; then
            echo "Found dist/apps/nellab/.next (Nx static export)"
            echo "directory=dist/apps/nellab/.next" >> $GITHUB_OUTPUT
          elif [ -d "dist/apps/nellab" ]; then
            echo "Found dist/apps/nellab"
            echo "directory=dist/apps/nellab" >> $GITHUB_OUTPUT
          else
            echo "‚ùå No static export output found!"
            ls -la apps/nellab/ 2>/dev/null | head -10
            ls -la dist/ 2>/dev/null | head -10 || echo "dist/ doesn't exist"
            exit 1
          fi

      - name: Deploy to Cloudflare Pages
        uses: cloudflare/pages-action@v1
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          projectName: ryla-nellab
          directory: ${{ steps.find-output.outputs.directory }}
          gitHubToken: ${{ secrets.GITHUB_TOKEN }}

      - name: Notify Slack
        if: success()
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text":"DEPLOY: ${{ needs.detect-environment.outputs.github_env }} ${{ github.ref_name }} - nellab app success (Cloudflare Pages)"}' \
            ${{ secrets.SLACK_WEBHOOK_DEPLOYS || 'https://hooks.slack.com/services/PLACEHOLDER' }}
        continue-on-error: true

  deploy-admin:
    name: Deploy Admin App
    needs: [detect-environment, detect-changes]
    if: needs.detect-changes.outputs.admin == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.detect-environment.outputs.github_env }}
    # Cancel in-progress admin app deployments when new commit affects admin app
    concurrency:
      group: deploy-admin-${{ github.ref }}
      cancel-in-progress: true
    steps:
      - name: Install Git LFS (before checkout)
        run: |
          sudo apt-get update
          sudo apt-get install -y git-lfs
          git lfs install

      - uses: actions/checkout@v4
        with:
          lfs: false # Disable LFS in checkout, we'll handle it manually
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Configure Git LFS and pull files
        run: |
          set +e  # Don't fail job on LFS/git errors; deployment doesn't require LFS
          git lfs install 2>/dev/null || echo "‚ö†Ô∏è  Git LFS install failed, continuing..."
          git config --global credential.helper store 2>/dev/null || true
          echo "https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com" > ~/.git-credentials 2>/dev/null || true
          git lfs pull 2>&1 || echo "‚ö†Ô∏è  Git LFS pull failed, continuing without LFS files..."
          echo "‚úÖ Git LFS configuration complete (or skipped)"
          exit 0  # Always succeed so deploy continues

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Enable corepack (for pnpm)
        run: |
          corepack enable
          corepack prepare pnpm@10.26.1 --activate
          echo "pnpm version: $(pnpm --version)"

      - name: Install dependencies (optional - Docker handles deps)
        timeout-minutes: 15
        continue-on-error: true
        run: |
          set +e  # Don't exit on error, we'll handle it manually

          echo "Installing dependencies..."
          echo "pnpm version: $(pnpm --version || echo 'not found')"
          echo "Node version: $(node --version || echo 'not found')"
          echo "Working directory: $(pwd)"
          echo "Checking lockfile..."
          ls -la pnpm-lock.yaml || echo "‚ö†Ô∏è  pnpm-lock.yaml not found"

          # Set pnpm config for CI
          pnpm config set store-dir ~/.pnpm-store || true
          pnpm config set network-timeout 180000 || true
          pnpm config set fetch-retries 5 || true
          pnpm config set fetch-retry-mintimeout 10000 || true
          pnpm config set fetch-retry-maxtimeout 60000 || true

          # Clear pnpm store cache if it exists (might be corrupted)
          echo "Clearing pnpm store cache..."
          rm -rf ~/.pnpm-store || true

          # Try install - start without --frozen-lockfile for better compatibility
          echo "Running pnpm install (without --frozen-lockfile for CI compatibility)..."
          pnpm install --network-timeout=180000 --reporter=append-only 2>&1 | tee /tmp/pnpm-install.log
          INSTALL_STATUS=${PIPESTATUS[0]}

          if [ $INSTALL_STATUS -ne 0 ]; then
            echo "‚ö†Ô∏è  pnpm install failed (exit code: $INSTALL_STATUS)"
            echo "Last 100 lines of pnpm install log:"
            tail -100 /tmp/pnpm-install.log || echo "Could not read log"
            echo "Trying with --frozen-lockfile..."
            pnpm install --frozen-lockfile --network-timeout=180000 --reporter=append-only 2>&1 | tee /tmp/pnpm-install-frozen.log
            INSTALL_STATUS=${PIPESTATUS[0]}
            
            if [ $INSTALL_STATUS -ne 0 ]; then
              echo "‚ùå pnpm install failed completely (exit code: $INSTALL_STATUS)"
              echo "Last 100 lines of frozen lockfile log:"
              tail -100 /tmp/pnpm-install-frozen.log || echo "Could not read frozen log"
              echo "Checking pnpm and node versions..."
              pnpm --version || echo "pnpm not available"
              node --version || echo "node not available"
              echo "Checking if lockfile exists..."
              ls -la pnpm-lock.yaml || echo "Lockfile missing"
              echo "Checking disk space..."
              df -h || echo "Cannot check disk space"
              echo "Checking memory..."
              free -h || echo "Cannot check memory"
              echo "Checking network connectivity..."
              curl -I https://registry.npmjs.org/ || echo "Cannot reach npm registry"
              echo "‚ö†Ô∏è  pnpm install failed, but continuing - Docker build will handle dependencies"
              exit 0  # Don't fail - Docker will install deps
            fi
          fi

          echo "‚úÖ Dependencies installed successfully"

      - name: Setup Fly.io CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Install Infisical CLI
        run: |
          curl -1sLf 'https://dl.cloudsmith.io/public/infisical/infisical-cli/setup.deb.sh' | sudo -E bash
          sudo apt-get install infisical

      - name: Export Build Args from Infisical
        id: build-args
        env:
          INFISICAL_TOKEN: ${{ secrets.INFISICAL_TOKEN }}
        run: |
          echo "üì¶ Exporting build args from Infisical (${{ needs.detect-environment.outputs.infisical_env }})..."

          # Verify Infisical CLI is installed
          if ! command -v infisical &> /dev/null; then
            echo "‚ùå Infisical CLI not found"
            exit 1
          fi

          echo "Infisical CLI version: $(infisical --version || echo 'unknown')"

          # Check if INFISICAL_TOKEN is set
          if [ -z "$INFISICAL_TOKEN" ]; then
            echo "‚ùå INFISICAL_TOKEN is not set"
            exit 1
          fi

          # Export secrets to temporary file
          # Try with /apps/admin first, fallback to /shared only if folder doesn't exist
          # Note: Redirect stderr separately and filter output to only include valid dotenv lines
          if ! infisical export \
            --domain=https://eu.infisical.com/api \
            --path=/apps/admin \
            --path=/shared \
            --env=${{ needs.detect-environment.outputs.infisical_env }} \
            --format=dotenv 2>/tmp/infisical-stderr.log | grep -E '^[A-Z_]+=.*' > /tmp/build-args.env; then
            echo "‚ö†Ô∏è  Failed to export from /apps/admin, trying /shared only..."
            echo "Stderr from first attempt:"
            cat /tmp/infisical-stderr.log || true
            if ! infisical export \
              --domain=https://eu.infisical.com/api \
              --path=/shared \
              --env=${{ needs.detect-environment.outputs.infisical_env }} \
              --format=dotenv 2>/tmp/infisical-stderr.log | grep -E '^[A-Z_]+=.*' > /tmp/build-args.env; then
              echo "‚ùå Failed to export secrets from Infisical"
              echo "Stderr output:"
              cat /tmp/infisical-stderr.log || echo "Could not read stderr"
              exit 1
            fi
          fi

          # Check if file was created and has content
          if [ ! -s /tmp/build-args.env ]; then
            echo "‚ö†Ô∏è  Build args file is empty, but continuing with defaults..."
            echo "# Empty build args - using code defaults" > /tmp/build-args.env
          fi

          # Source the file to make variables available (now safe - only contains valid dotenv lines)
          set -a
          source /tmp/build-args.env
          set +a

          # Verify required variables are set
          if [ -z "$NEXT_PUBLIC_SITE_URL" ]; then
            echo "‚ö†Ô∏è  WARNING: NEXT_PUBLIC_SITE_URL is not set"
          fi
          if [ -z "$NEXT_PUBLIC_API_URL" ]; then
            echo "‚ö†Ô∏è  WARNING: NEXT_PUBLIC_API_URL is not set"
          fi

          # Set as outputs for use in deployment step (with defaults to prevent empty values)
          echo "site_url=${NEXT_PUBLIC_SITE_URL:-}" >> $GITHUB_OUTPUT
          echo "api_url=${NEXT_PUBLIC_API_URL:-}" >> $GITHUB_OUTPUT
          echo "api_base_url=${NEXT_PUBLIC_API_BASE_URL:-}" >> $GITHUB_OUTPUT
          echo "posthog_key=${NEXT_PUBLIC_POSTHOG_KEY:-}" >> $GITHUB_OUTPUT
          echo "posthog_host=${NEXT_PUBLIC_POSTHOG_HOST:-}" >> $GITHUB_OUTPUT
          echo "supabase_url=${NEXT_PUBLIC_SUPABASE_URL:-}" >> $GITHUB_OUTPUT
          echo "supabase_anon_key=${NEXT_PUBLIC_SUPABASE_ANON_KEY:-}" >> $GITHUB_OUTPUT

          echo "‚úÖ Build args exported"
          echo "  NEXT_PUBLIC_SITE_URL: ${NEXT_PUBLIC_SITE_URL:-<not set>}"
          echo "  NEXT_PUBLIC_API_URL: ${NEXT_PUBLIC_API_URL:-<not set>}"

      - name: Stop old machines (if any)
        run: |
          # Install jq if not available
          sudo apt-get update && sudo apt-get install -y jq || true
          # Stop all machines for this app to ensure clean deployment
          MACHINES=$(flyctl machines list --app ryla-admin-${{ needs.detect-environment.outputs.fly_suffix }} --json 2>/dev/null || echo "[]")
          echo "$MACHINES" | jq -r '.[].id' | while read machine_id; do
            if [ -n "$machine_id" ]; then
              echo "Stopping machine: $machine_id"
              flyctl machines stop "$machine_id" --app ryla-admin-${{ needs.detect-environment.outputs.fly_suffix }} || true
            fi
          done
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        continue-on-error: true

      - name: Sync Runtime Secrets to Fly.io (via Infisical)
        run: |
          echo "üîÑ Syncing runtime secrets from Infisical to Fly.io..."
          echo "Environment: ${{ needs.detect-environment.outputs.infisical_env }}"

          # Export secrets from Infisical and set them in Fly.io
          infisical export \
            --domain=https://eu.infisical.com/api \
            --path=/apps/admin \
            --path=/shared \
            --env=${{ needs.detect-environment.outputs.infisical_env }} \
            --format=dotenv | while IFS='=' read -r key value; do
            # Skip NEXT_PUBLIC_* variables (they're build args, not runtime secrets)
            if [[ ! "$key" =~ ^NEXT_PUBLIC_ ]]; then
              if [ -n "$key" ] && [ -n "$value" ]; then
                echo "Setting secret: $key"
                flyctl secrets set "$key=$value" --app ryla-admin-${{ needs.detect-environment.outputs.fly_suffix }} || true
              fi
            fi
          done
        env:
          INFISICAL_TOKEN: ${{ secrets.INFISICAL_TOKEN }}
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        continue-on-error: true

      - name: Deploy Admin App to Fly.io
        run: |
          flyctl deploy \
            --config apps/admin/fly.toml \
            --dockerfile apps/admin/Dockerfile \
            --app ryla-admin-${{ needs.detect-environment.outputs.fly_suffix }} \
            --strategy immediate \
            --build-arg NEXT_PUBLIC_SITE_URL="${{ steps.build-args.outputs.site_url }}" \
            --build-arg NEXT_PUBLIC_API_URL="${{ steps.build-args.outputs.api_url }}" \
            --build-arg NEXT_PUBLIC_API_BASE_URL="${{ steps.build-args.outputs.api_base_url }}" \
            --build-arg NEXT_PUBLIC_POSTHOG_HOST="${{ steps.build-args.outputs.posthog_host }}" \
            --build-arg NEXT_PUBLIC_POSTHOG_KEY="${{ steps.build-args.outputs.posthog_key }}" \
            --build-arg NEXT_PUBLIC_SUPABASE_URL="${{ steps.build-args.outputs.supabase_url }}" \
            --build-arg NEXT_PUBLIC_SUPABASE_ANON_KEY="${{ steps.build-args.outputs.supabase_anon_key }}"
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}

      - name: Health Check
        run: |
          sleep 10
          flyctl status --app ryla-admin-${{ needs.detect-environment.outputs.fly_suffix }}
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}

      - name: Notify Slack
        if: success()
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text":"DEPLOY: ${{ needs.detect-environment.outputs.github_env }} ${{ github.ref_name }} - admin app success"}' \
            ${{ secrets.SLACK_WEBHOOK_DEPLOYS || 'https://hooks.slack.com/services/PLACEHOLDER' }}
        continue-on-error: true

  deploy-metabase:
    name: Deploy Metabase (Fly.io)
    needs: [detect-environment, detect-changes]
    if: needs.detect-changes.outputs.metabase == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.detect-environment.outputs.github_env }}
    concurrency:
      group: deploy-metabase-${{ github.ref }}
      cancel-in-progress: true
    steps:
      - uses: actions/checkout@v4
        with:
          lfs: false

      - name: Setup Fly.io CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Ensure Fly app exists (create once from terminal if missing)
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
          FLY_ORG: ${{ secrets.FLY_ORG }}
        run: |
          APP_NAME="ryla-metabase-${{ needs.detect-environment.outputs.fly_suffix }}"
          ORG="${FLY_ORG:-my-dream-companion}"
          if flyctl apps list --org "$ORG" 2>/dev/null | grep -q "$APP_NAME"; then
            echo "App $APP_NAME exists in org $ORG."
            exit 0
          fi
          echo "App $APP_NAME not found in org $ORG. Create it once from your terminal:"
          echo ""
          echo "  flyctl apps create $APP_NAME --yes --org $ORG"
          echo "  flyctl volumes create metabase_data --region fra --size 1 --app $APP_NAME --org $ORG"
          echo ""
          exit 1

      - name: Deploy Metabase to Fly.io
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
          FLY_ORG: ${{ secrets.FLY_ORG }}
        run: |
          set -e
          APP_NAME="ryla-metabase-${{ needs.detect-environment.outputs.fly_suffix }}"
          export FLY_ORG="${FLY_ORG:-my-dream-companion}"
          echo "Deploying to app: $APP_NAME (org: $FLY_ORG)"
          flyctl deploy \
            --config apps/metabase/fly.toml \
            --dockerfile apps/metabase/Dockerfile \
            --app "$APP_NAME" \
            --strategy immediate \
            --verbose

      - name: Wait for Metabase to be ready
        run: |
          METABASE_URL="https://ryla-metabase-${{ needs.detect-environment.outputs.fly_suffix }}.fly.dev"
          echo "Waiting for Metabase at $METABASE_URL ..."
          for i in $(seq 1 30); do
            if curl -sf "$METABASE_URL/api/health" > /dev/null 2>&1; then
              echo "Metabase is up."
              exit 0
            fi
            sleep 10
          done
          echo "Metabase did not become ready in time (setup step may still run if API is available later)."
        continue-on-error: true

      - name: Install Infisical CLI
        run: |
          curl -1sLf 'https://dl.cloudsmith.io/public/infisical/infisical-cli/setup.deb.sh' | sudo -E bash
          sudo apt-get install -y infisical

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Enable corepack (pnpm)
        run: corepack enable pnpm && corepack prepare pnpm@10.26.1 --activate

      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        continue-on-error: true

      - name: Setup RYLA dashboards in Metabase
        env:
          INFISICAL_TOKEN: ${{ secrets.INFISICAL_TOKEN }}
          # Override METABASE_URL so dashboard script targets the deployed instance
          METABASE_URL: 'https://ryla-metabase-${{ needs.detect-environment.outputs.fly_suffix }}.fly.dev'
        run: |
          echo "Running dashboard setup against $METABASE_URL ..."
          # Infisical injects METABASE_API_KEY from /mcp; METABASE_URL is set above for this env
          infisical run \
            --domain=https://eu.infisical.com/api \
            --path=/mcp \
            --env=${{ needs.detect-environment.outputs.infisical_env }} \
            -- pnpm tsx scripts/setup/metabase-setup-dashboards.ts
        continue-on-error: true

      - name: Notify Slack
        if: success()
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text":"DEPLOY: ${{ needs.detect-environment.outputs.github_env }} ${{ github.ref_name }} - Metabase success (Fly.io)"}' \
            ${{ secrets.SLACK_WEBHOOK_DEPLOYS || 'https://hooks.slack.com/services/PLACEHOLDER' }}
        continue-on-error: true
