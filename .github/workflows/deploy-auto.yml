name: Auto Deploy (Nx Affected)

on:
  push:
    branches: [main, staging]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: false
        type: choice
        options:
          - staging
          - production

permissions:
  contents: read
  pull-requests: read

jobs:
  detect-environment:
    name: Detect Environment
    runs-on: ubuntu-latest
    outputs:
      infisical_env: ${{ steps.env.outputs.infisical_env }}
      fly_suffix: ${{ steps.env.outputs.fly_suffix }}
      github_env: ${{ steps.env.outputs.github_env }}
    steps:
      - name: Determine Environment
        id: env
        run: |
          # Determine environment from input, branch, or default to production
          if [ -n "${{ github.event.inputs.environment }}" ]; then
            GITHUB_ENV="${{ github.event.inputs.environment }}"
          elif [ "${{ github.ref }}" == "refs/heads/staging" ]; then
            GITHUB_ENV="staging"
          elif [ "${{ github.ref }}" == "refs/heads/main" ]; then
            GITHUB_ENV="production"
          else
            GITHUB_ENV="production"
          fi
          
          # Map GitHub environment to Infisical environment
          if [ "$GITHUB_ENV" == "production" ]; then
            echo "infisical_env=prod" >> $GITHUB_OUTPUT
            echo "fly_suffix=prod" >> $GITHUB_OUTPUT
            echo "github_env=production" >> $GITHUB_OUTPUT
          elif [ "$GITHUB_ENV" == "staging" ]; then
            echo "infisical_env=staging" >> $GITHUB_OUTPUT
            echo "fly_suffix=staging" >> $GITHUB_OUTPUT
            echo "github_env=staging" >> $GITHUB_OUTPUT
          else
            echo "infisical_env=dev" >> $GITHUB_OUTPUT
            echo "fly_suffix=dev" >> $GITHUB_OUTPUT
            echo "github_env=development" >> $GITHUB_OUTPUT
          fi
          
          echo "âœ… Environment determined:"
          echo "  GitHub Environment: $GITHUB_ENV"
          echo "  Infisical Environment: $(cat $GITHUB_OUTPUT | grep infisical_env | cut -d'=' -f2)"
          echo "  Fly.io Suffix: $(cat $GITHUB_OUTPUT | grep fly_suffix | cut -d'=' -f2)"

  detect-changes:
    name: Detect Changed Apps
    runs-on: ubuntu-latest
    outputs:
      web: ${{ steps.affected.outputs.web }}
      api: ${{ steps.affected.outputs.api }}
      funnel: ${{ steps.affected.outputs.funnel }}
      landing: ${{ steps.affected.outputs.landing }}
      admin: ${{ steps.affected.outputs.admin }}
      has-changes: ${{ steps.affected.outputs.has-changes }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history for Nx affected
          token: ${{ secrets.GITHUB_TOKEN }}
          lfs: true  # Pull Git LFS files (images are stored in LFS)

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Enable corepack (for pnpm)
        run: corepack enable

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Detect affected apps
        id: affected
        run: |
          # Get base commit (previous commit on main, or main branch if first commit)
          # For push events, use github.event.before if available, otherwise HEAD~1
          if [ "${{ github.event_name }}" = "push" ]; then
            # Use github.event.before if it exists and is valid, otherwise use HEAD~1
            if [ -n "${{ github.event.before }}" ] && [ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]; then
              BASE="${{ github.event.before }}"
            else
              BASE=$(git rev-parse HEAD~1 2>/dev/null || echo "origin/main")
            fi
            HEAD=$(git rev-parse HEAD)
          else
            # For workflow_dispatch, compare with origin/main
            git fetch origin main || true
            BASE=$(git merge-base HEAD origin/main 2>/dev/null || echo "origin/main")
            HEAD=$(git rev-parse HEAD)
          fi
          
          echo "Base: $BASE"
          echo "Head: $HEAD"
          
          # Check which apps are affected using Nx show projects
          # Nx show projects --affected returns projects that changed
          AFFECTED=$(pnpm nx show projects --affected --base=$BASE --head=$HEAD 2>/dev/null || echo "")
          
          echo "Affected projects: $AFFECTED"
          
          # Set outputs for each app
          if echo "$AFFECTED" | grep -qE "(^|\s)web(\s|$)"; then
            echo "web=true" >> $GITHUB_OUTPUT
            echo "âœ“ Web app affected"
          else
            echo "web=false" >> $GITHUB_OUTPUT
            echo "âœ— Web app not affected"
          fi
          
          if echo "$AFFECTED" | grep -qE "(^|\s)api(\s|$)"; then
            echo "api=true" >> $GITHUB_OUTPUT
            echo "âœ“ API app affected"
          else
            echo "api=false" >> $GITHUB_OUTPUT
            echo "âœ— API app not affected"
          fi
          
          if echo "$AFFECTED" | grep -qE "(^|\s)funnel(\s|$)"; then
            echo "funnel=true" >> $GITHUB_OUTPUT
            echo "âœ“ Funnel app affected"
          else
            echo "funnel=false" >> $GITHUB_OUTPUT
            echo "âœ— Funnel app not affected"
          fi
          
          if echo "$AFFECTED" | grep -qE "(^|\s)landing(\s|$)"; then
            echo "landing=true" >> $GITHUB_OUTPUT
            echo "âœ“ Landing app affected"
          else
            echo "landing=false" >> $GITHUB_OUTPUT
            echo "âœ— Landing app not affected"
          fi
          
          if echo "$AFFECTED" | grep -qE "(^|\s)admin(\s|$)"; then
            echo "admin=true" >> $GITHUB_OUTPUT
            echo "âœ“ Admin app affected"
          else
            echo "admin=false" >> $GITHUB_OUTPUT
            echo "âœ— Admin app not affected"
          fi
          
          if [ -z "$AFFECTED" ] || ! echo "$AFFECTED" | grep -qE "(^|\s)(web|api|funnel|landing|admin)(\s|$)"; then
            echo "has-changes=false" >> $GITHUB_OUTPUT
            echo "No app changes detected"
          else
            echo "has-changes=true" >> $GITHUB_OUTPUT
            echo "App changes detected"
          fi

  deploy-web:
    name: Deploy Web App
    needs: [detect-environment, detect-changes]
    if: needs.detect-changes.outputs.web == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.detect-environment.outputs.github_env }}
    # Cancel in-progress web app deployments when new commit affects web app
    concurrency:
      group: deploy-web-${{ github.ref }}
      cancel-in-progress: true
    steps:
      - uses: actions/checkout@v4
        with:
          lfs: true  # Pull Git LFS files (images are stored in LFS)

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Enable corepack (for pnpm)
        run: corepack enable

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Verify images from Git LFS before build
        run: |
          echo "========================================="
          echo "Verifying images from Git LFS are present"
          echo "========================================="
          echo "Images should be pulled automatically via checkout with lfs: true"
          echo ""
          echo "Checking image directories:"
          if [ -d "./apps/web/public/images" ]; then
            echo "âœ… Found apps/web/public/images/"
            echo ""
            echo "Age range images: $(find ./apps/web/public/images/age-ranges -name "*.webp" 2>/dev/null | wc -l | tr -d ' ') files"
            echo "Skin color images: $(find ./apps/web/public/images/skin-colors -name "*.webp" 2>/dev/null | wc -l | tr -d ' ') files"
            echo "Ethnicity images: $(find ./apps/web/public/images/ethnicity -name "*.webp" 2>/dev/null | wc -l | tr -d ' ') files"
            echo ""
            echo "Sample files:"
            ls -1 ./apps/web/public/images/age-ranges/*.webp 2>/dev/null | head -3 || echo "  âš ï¸ No age range images found"
            ls -1 ./apps/web/public/images/skin-colors/*.webp 2>/dev/null | head -3 || echo "  âš ï¸ No skin color images found"
            echo ""
            echo "Skin colors by ethnicity:"
            find ./apps/web/public/images/skin-colors -type d -mindepth 1 2>/dev/null | while read dir; do
              count=$(find "$dir" -name "*.webp" 2>/dev/null | wc -l | tr -d ' ')
              echo "  $dir: $count files"
            done || echo "  No ethnicity-specific directories found"
          else
            echo "âŒ ERROR: apps/web/public/images/ not found!"
            echo "Git LFS files may not have been pulled correctly."
            exit 1
          fi

      - name: Setup Fly.io CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Install Infisical CLI
        run: |
          curl -1sLf 'https://dl.cloudsmith.io/public/infisical/infisical-cli/setup.deb.sh' | sudo -E bash
          sudo apt-get install infisical

      - name: Export Build Args from Infisical
        id: build-args
        env:
          INFISICAL_TOKEN: ${{ secrets.INFISICAL_TOKEN }}
        run: |
          echo "ðŸ“¦ Exporting build args from Infisical (${{ needs.detect-environment.outputs.infisical_env }})..."
          
          # Export secrets to temporary file
          infisical export \
            --path=/apps/web \
            --path=/shared \
            --env=${{ needs.detect-environment.outputs.infisical_env }} \
            --format=dotenv > /tmp/build-args.env
          
          # Source the file to make variables available
          set -a
          source /tmp/build-args.env
          set +a
          
          # Set as outputs for use in deployment step
          echo "api_url=$NEXT_PUBLIC_API_URL" >> $GITHUB_OUTPUT
          echo "site_url=$NEXT_PUBLIC_SITE_URL" >> $GITHUB_OUTPUT
          echo "posthog_key=$NEXT_PUBLIC_POSTHOG_KEY" >> $GITHUB_OUTPUT
          echo "posthog_host=$NEXT_PUBLIC_POSTHOG_HOST" >> $GITHUB_OUTPUT
          echo "supabase_url=$NEXT_PUBLIC_SUPABASE_URL" >> $GITHUB_OUTPUT
          echo "supabase_anon_key=$NEXT_PUBLIC_SUPABASE_ANON_KEY" >> $GITHUB_OUTPUT
          
          echo "âœ… Build args exported"
          echo "  NEXT_PUBLIC_API_URL: $NEXT_PUBLIC_API_URL"
          echo "  NEXT_PUBLIC_SITE_URL: $NEXT_PUBLIC_SITE_URL"

      - name: Setup Fly.io CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Stop old machines (if any)
        run: |
          # Install jq if not available
          sudo apt-get update && sudo apt-get install -y jq || true
          # Stop all machines for this app to ensure clean deployment
          MACHINES=$(flyctl machines list --app ryla-web-${{ needs.detect-environment.outputs.fly_suffix }} --json 2>/dev/null || echo "[]")
          echo "$MACHINES" | jq -r '.[].id' | while read machine_id; do
            if [ -n "$machine_id" ]; then
              echo "Stopping machine: $machine_id"
              flyctl machines stop "$machine_id" --app ryla-web-${{ needs.detect-environment.outputs.fly_suffix }} || true
            fi
          done
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        continue-on-error: true

      - name: Verify images in build context
        run: |
          echo "========================================="; \
          echo "Final verification before Docker build"; \
          echo "========================================="; \
          echo "Checking if images exist in apps/web/public/images:"; \
          if [ -d "./apps/web/public/images" ]; then \
            echo "âœ… Images directory exists"; \
            echo "Age ranges: $(find ./apps/web/public/images/age-ranges -name "*.webp" 2>/dev/null | wc -l | tr -d ' ') files"; \
            echo "Skin colors: $(find ./apps/web/public/images/skin-colors -name "*.webp" 2>/dev/null | wc -l | tr -d ' ') files"; \
            echo "Ethnicity: $(find ./apps/web/public/images/ethnicity -name "*.webp" 2>/dev/null | wc -l | tr -d ' ') files"; \
            echo "Sample paths:"; \
            ls -1 ./apps/web/public/images/age-ranges/*.webp 2>/dev/null | head -3 || echo "  No age range images"; \
            ls -1 ./apps/web/public/images/skin-colors/*.webp 2>/dev/null | head -3 || echo "  No skin color images"; \
          else \
            echo "âŒ Images directory does not exist!"; \
            exit 1; \
          fi

      - name: Sync Runtime Secrets to Fly.io (via Infisical)
        run: |
          echo "ðŸ”„ Syncing runtime secrets from Infisical to Fly.io..."
          echo "Environment: ${{ needs.detect-environment.outputs.infisical_env }}"
          
          # Export secrets from Infisical and set them in Fly.io
          infisical export \
            --path=/apps/web \
            --path=/shared \
            --env=${{ needs.detect-environment.outputs.infisical_env }} \
            --format=dotenv | while IFS='=' read -r key value; do
            # Skip empty lines and comments
            [[ -z "$key" || "$key" =~ ^# ]] && continue
            # Skip NEXT_PUBLIC_* (these are build args, not runtime secrets)
            [[ "$key" =~ ^NEXT_PUBLIC_ ]] && continue
            # Remove quotes from value if present
            value="${value%\"}"
            value="${value#\"}"
            echo "  Setting $key..."
            flyctl secrets set "$key=$value" --app ryla-web-${{ needs.detect-environment.outputs.fly_suffix }} --stage
          done
          
          # Deploy staged secrets
          flyctl secrets deploy --app ryla-web-${{ needs.detect-environment.outputs.fly_suffix }}
          echo "âœ… Secrets synced successfully"
        env:
          INFISICAL_TOKEN: ${{ secrets.INFISICAL_TOKEN }}
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        continue-on-error: true

      - name: Deploy Web App to Fly.io
        run: |
          flyctl deploy \
            --config apps/web/fly.toml \
            --dockerfile apps/web/Dockerfile \
            --app ryla-web-${{ needs.detect-environment.outputs.fly_suffix }} \
            --strategy immediate \
            --build-arg NEXT_PUBLIC_API_URL="${{ steps.build-args.outputs.api_url }}" \
            --build-arg NEXT_PUBLIC_SITE_URL="${{ steps.build-args.outputs.site_url }}" \
            --build-arg NEXT_PUBLIC_POSTHOG_KEY="${{ steps.build-args.outputs.posthog_key }}" \
            --build-arg NEXT_PUBLIC_POSTHOG_HOST="${{ steps.build-args.outputs.posthog_host }}" \
            --build-arg NEXT_PUBLIC_SUPABASE_URL="${{ steps.build-args.outputs.supabase_url }}" \
            --build-arg NEXT_PUBLIC_SUPABASE_ANON_KEY="${{ steps.build-args.outputs.supabase_anon_key }}"
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}

      - name: Health Check
        run: |
          sleep 10
          flyctl status --app ryla-web-${{ needs.detect-environment.outputs.fly_suffix }}
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}

      - name: Notify Slack
        if: success()
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text":"DEPLOY: production ${{ github.ref_name }} - web app success"}' \
            ${{ secrets.SLACK_WEBHOOK_DEPLOYS || 'https://hooks.slack.com/services/PLACEHOLDER' }}
        continue-on-error: true

  deploy-api:
    name: Deploy API App
    needs: [detect-environment, detect-changes]
    if: needs.detect-changes.outputs.api == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.detect-environment.outputs.github_env }}
    # Cancel in-progress API app deployments when new commit affects API app
    concurrency:
      group: deploy-api-${{ github.ref }}
      cancel-in-progress: true
    steps:
      - uses: actions/checkout@v4
        with:
          lfs: true  # Pull Git LFS files (images are stored in LFS)

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Enable corepack (for pnpm)
        run: corepack enable

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Setup Fly.io CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Install Infisical CLI
        run: |
          curl -1sLf 'https://dl.cloudsmith.io/public/infisical/infisical-cli/setup.deb.sh' | sudo -E bash
          sudo apt-get install infisical

      - name: Setup Fly.io CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Stop old machines (if any)
        run: |
          # Install jq if not available
          sudo apt-get update && sudo apt-get install -y jq || true
          # Stop all machines for this app to ensure clean deployment
          MACHINES=$(flyctl machines list --app ryla-api-${{ needs.detect-environment.outputs.fly_suffix }} --json 2>/dev/null || echo "[]")
          echo "$MACHINES" | jq -r '.[].id' | while read machine_id; do
            if [ -n "$machine_id" ]; then
              echo "Stopping machine: $machine_id"
              flyctl machines stop "$machine_id" --app ryla-api-${{ needs.detect-environment.outputs.fly_suffix }} || true
            fi
          done
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        continue-on-error: true

      - name: Sync Runtime Secrets to Fly.io (via Infisical)
        run: |
          echo "ðŸ”„ Syncing runtime secrets from Infisical to Fly.io..."
          echo "Environment: ${{ needs.detect-environment.outputs.infisical_env }}"
          
          # Export secrets from Infisical and set them in Fly.io
          infisical export \
            --path=/apps/api \
            --path=/shared \
            --env=${{ needs.detect-environment.outputs.infisical_env }} \
            --format=dotenv | while IFS='=' read -r key value; do
            # Skip empty lines and comments
            [[ -z "$key" || "$key" =~ ^# ]] && continue
            # Remove quotes from value if present
            value="${value%\"}"
            value="${value#\"}"
            echo "  Setting $key..."
            flyctl secrets set "$key=$value" --app ryla-api-${{ needs.detect-environment.outputs.fly_suffix }} --stage
          done
          
          # Deploy staged secrets
          flyctl secrets deploy --app ryla-api-${{ needs.detect-environment.outputs.fly_suffix }}
          echo "âœ… Secrets synced successfully"
        env:
          INFISICAL_TOKEN: ${{ secrets.INFISICAL_TOKEN }}
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        continue-on-error: true

      - name: Deploy API App to Fly.io
        run: |
          flyctl deploy \
            --config apps/api/fly.toml \
            --dockerfile apps/api/Dockerfile \
            --app ryla-api-${{ needs.detect-environment.outputs.fly_suffix }} \
            --strategy immediate
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}

      - name: Health Check
        run: |
          sleep 10
          flyctl status --app ryla-api-${{ needs.detect-environment.outputs.fly_suffix }}
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}

      - name: Notify Slack
        if: success()
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text":"DEPLOY: production ${{ github.ref_name }} - api app success"}' \
            ${{ secrets.SLACK_WEBHOOK_DEPLOYS || 'https://hooks.slack.com/services/PLACEHOLDER' }}
        continue-on-error: true

  deploy-funnel:
    name: Deploy Funnel App
    needs: [detect-environment, detect-changes]
    if: needs.detect-changes.outputs.funnel == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.detect-environment.outputs.github_env }}
    # Cancel in-progress funnel app deployments when new commit affects funnel app
    concurrency:
      group: deploy-funnel-${{ github.ref }}
      cancel-in-progress: true
    steps:
      - uses: actions/checkout@v4
        with:
          lfs: true  # Pull Git LFS files (images are stored in LFS)

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Enable corepack (for pnpm)
        run: corepack enable

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Setup Fly.io CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Install Infisical CLI
        run: |
          curl -1sLf 'https://dl.cloudsmith.io/public/infisical/infisical-cli/setup.deb.sh' | sudo -E bash
          sudo apt-get install infisical

      - name: Export Build Args from Infisical
        id: build-args
        env:
          INFISICAL_TOKEN: ${{ secrets.INFISICAL_TOKEN }}
        run: |
          echo "ðŸ“¦ Exporting build args from Infisical (${{ needs.detect-environment.outputs.infisical_env }})..."
          
          # Export secrets to temporary file
          infisical export \
            --path=/apps/funnel \
            --path=/shared \
            --env=${{ needs.detect-environment.outputs.infisical_env }} \
            --format=dotenv > /tmp/build-args.env
          
          # Source the file to make variables available
          set -a
          source /tmp/build-args.env
          set +a
          
          # Set as outputs for use in deployment step
          echo "cdn_url=$NEXT_PUBLIC_CDN_URL" >> $GITHUB_OUTPUT
          echo "debug_cdn=$NEXT_PUBLIC_DEBUG_CDN" >> $GITHUB_OUTPUT
          echo "site_url=$NEXT_PUBLIC_SITE_URL_FUNNEL" >> $GITHUB_OUTPUT
          echo "api_base_url=$NEXT_PUBLIC_API_BASE_URL" >> $GITHUB_OUTPUT
          echo "finby_redirect=$NEXT_PUBLIC_FINBY_PAYMENT_REDIRECT" >> $GITHUB_OUTPUT
          echo "posthog_host=$NEXT_PUBLIC_POSTHOG_HOST" >> $GITHUB_OUTPUT
          echo "posthog_key=$NEXT_PUBLIC_POSTHOG_KEY" >> $GITHUB_OUTPUT
          echo "supabase_url=$NEXT_PUBLIC_SUPABASE_URL" >> $GITHUB_OUTPUT
          echo "supabase_anon_key=$NEXT_PUBLIC_SUPABASE_ANON_KEY" >> $GITHUB_OUTPUT
          
          echo "âœ… Build args exported"

      - name: Setup Fly.io CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Stop old machines (if any)
        run: |
          # Install jq if not available
          sudo apt-get update && sudo apt-get install -y jq || true
          # Stop all machines for this app to ensure clean deployment
          MACHINES=$(flyctl machines list --app ryla-funnel-${{ needs.detect-environment.outputs.fly_suffix }} --json 2>/dev/null || echo "[]")
          echo "$MACHINES" | jq -r '.[].id' | while read machine_id; do
            if [ -n "$machine_id" ]; then
              echo "Stopping machine: $machine_id"
              flyctl machines stop "$machine_id" --app ryla-funnel-${{ needs.detect-environment.outputs.fly_suffix }} || true
            fi
          done
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        continue-on-error: true

      - name: Deploy Funnel App to Fly.io
        run: |
          flyctl deploy \
            --config apps/funnel/fly.toml \
            --dockerfile apps/funnel/Dockerfile \
            --app ryla-funnel-${{ needs.detect-environment.outputs.fly_suffix }} \
            --strategy immediate \
            --build-arg NEXT_PUBLIC_CDN_URL="${{ steps.build-args.outputs.cdn_url }}" \
            --build-arg NEXT_PUBLIC_DEBUG_CDN="${{ steps.build-args.outputs.debug_cdn }}" \
            --build-arg NEXT_PUBLIC_SITE_URL="${{ steps.build-args.outputs.site_url }}" \
            --build-arg NEXT_PUBLIC_API_BASE_URL="${{ steps.build-args.outputs.api_base_url }}" \
            --build-arg NEXT_PUBLIC_FINBY_PAYMENT_REDIRECT="${{ steps.build-args.outputs.finby_redirect }}" \
            --build-arg NEXT_PUBLIC_POSTHOG_HOST="${{ steps.build-args.outputs.posthog_host }}" \
            --build-arg NEXT_PUBLIC_POSTHOG_KEY="${{ steps.build-args.outputs.posthog_key }}" \
            --build-arg NEXT_PUBLIC_SUPABASE_URL="${{ steps.build-args.outputs.supabase_url }}" \
            --build-arg NEXT_PUBLIC_SUPABASE_ANON_KEY="${{ steps.build-args.outputs.supabase_anon_key }}"
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}

      - name: Health Check
        run: |
          sleep 10
          flyctl status --app ryla-funnel-${{ needs.detect-environment.outputs.fly_suffix }}
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}

      - name: Notify Slack
        if: success()
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text":"DEPLOY: production ${{ github.ref_name }} - funnel app success"}' \
            ${{ secrets.SLACK_WEBHOOK_DEPLOYS || 'https://hooks.slack.com/services/PLACEHOLDER' }}
        continue-on-error: true

  deploy-landing:
    name: Deploy Landing App
    needs: [detect-environment, detect-changes]
    if: needs.detect-changes.outputs.landing == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.detect-environment.outputs.github_env }}
    # Cancel in-progress landing app deployments when new commit affects landing app
    concurrency:
      group: deploy-landing-${{ github.ref }}
      cancel-in-progress: true
    steps:
      - uses: actions/checkout@v4
        with:
          lfs: true  # Pull Git LFS files (images are stored in LFS)

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Enable corepack (for pnpm)
        run: corepack enable

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Setup Fly.io CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Install Infisical CLI
        run: |
          curl -1sLf 'https://dl.cloudsmith.io/public/infisical/infisical-cli/setup.deb.sh' | sudo -E bash
          sudo apt-get install infisical

      - name: Export Build Args from Infisical
        id: build-args
        env:
          INFISICAL_TOKEN: ${{ secrets.INFISICAL_TOKEN }}
        run: |
          echo "ðŸ“¦ Exporting build args from Infisical (${{ needs.detect-environment.outputs.infisical_env }})..."
          
          # Export secrets to temporary file
          infisical export \
            --path=/apps/landing \
            --path=/shared \
            --env=${{ needs.detect-environment.outputs.infisical_env }} \
            --format=dotenv > /tmp/build-args.env
          
          # Source the file to make variables available
          set -a
          source /tmp/build-args.env
          set +a
          
          # Set as outputs for use in deployment step
          echo "site_url=$NEXT_PUBLIC_SITE_URL_LANDING" >> $GITHUB_OUTPUT
          echo "cdn_url=$NEXT_PUBLIC_CDN_URL" >> $GITHUB_OUTPUT
          echo "debug_cdn=$NEXT_PUBLIC_DEBUG_CDN" >> $GITHUB_OUTPUT
          
          echo "âœ… Build args exported"

      - name: Setup Fly.io CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Stop old machines (if any)
        run: |
          # Install jq if not available
          sudo apt-get update && sudo apt-get install -y jq || true
          # Stop all machines for this app to ensure clean deployment
          MACHINES=$(flyctl machines list --app ryla-landing-${{ needs.detect-environment.outputs.fly_suffix }} --json 2>/dev/null || echo "[]")
          echo "$MACHINES" | jq -r '.[].id' | while read machine_id; do
            if [ -n "$machine_id" ]; then
              echo "Stopping machine: $machine_id"
              flyctl machines stop "$machine_id" --app ryla-landing-${{ needs.detect-environment.outputs.fly_suffix }} || true
            fi
          done
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        continue-on-error: true

      - name: Deploy Landing App to Fly.io
        run: |
          flyctl deploy \
            --config apps/landing/fly.toml \
            --dockerfile apps/landing/Dockerfile \
            --app ryla-landing-${{ needs.detect-environment.outputs.fly_suffix }} \
            --strategy immediate \
            --build-arg NEXT_PUBLIC_SITE_URL="${{ steps.build-args.outputs.site_url }}" \
            --build-arg NEXT_PUBLIC_CDN_URL="${{ steps.build-args.outputs.cdn_url }}" \
            --build-arg NEXT_PUBLIC_DEBUG_CDN="${{ steps.build-args.outputs.debug_cdn }}"
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}

      - name: Health Check
        run: |
          sleep 10
          flyctl status --app ryla-landing-${{ needs.detect-environment.outputs.fly_suffix }}
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}

      - name: Notify Slack
        if: success()
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text":"DEPLOY: production ${{ github.ref_name }} - landing app success"}' \
            ${{ secrets.SLACK_WEBHOOK_DEPLOYS || 'https://hooks.slack.com/services/PLACEHOLDER' }}
        continue-on-error: true
