name: Auto Deploy (Nx Affected)

on:
  push:
    branches: [main]
  workflow_dispatch:

# Cancel in-progress runs when a new commit is pushed
# This ensures only the latest commit gets deployed
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: read

jobs:
  detect-changes:
    name: Detect Changed Apps
    runs-on: ubuntu-latest
    outputs:
      web: ${{ steps.affected.outputs.web }}
      api: ${{ steps.affected.outputs.api }}
      funnel: ${{ steps.affected.outputs.funnel }}
      landing: ${{ steps.affected.outputs.landing }}
      has-changes: ${{ steps.affected.outputs.has-changes }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history for Nx affected
          token: ${{ secrets.GITHUB_TOKEN }}

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Enable corepack (for pnpm)
        run: corepack enable

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Detect affected apps
        id: affected
        run: |
          # Get base commit (previous commit on main, or main branch if first commit)
          # For push events, use github.event.before if available, otherwise HEAD~1
          if [ "${{ github.event_name }}" = "push" ]; then
            # Use github.event.before if it exists and is valid, otherwise use HEAD~1
            if [ -n "${{ github.event.before }}" ] && [ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]; then
              BASE="${{ github.event.before }}"
            else
              BASE=$(git rev-parse HEAD~1 2>/dev/null || echo "origin/main")
            fi
            HEAD=$(git rev-parse HEAD)
          else
            # For workflow_dispatch, compare with origin/main
            git fetch origin main || true
            BASE=$(git merge-base HEAD origin/main 2>/dev/null || echo "origin/main")
            HEAD=$(git rev-parse HEAD)
          fi
          
          echo "Base: $BASE"
          echo "Head: $HEAD"
          
          # Check which apps are affected using Nx show projects
          # Nx show projects --affected returns projects that changed
          AFFECTED=$(pnpm nx show projects --affected --base=$BASE --head=$HEAD 2>/dev/null || echo "")
          
          echo "Affected projects: $AFFECTED"
          
          # Set outputs for each app
          if echo "$AFFECTED" | grep -qE "(^|\s)web(\s|$)"; then
            echo "web=true" >> $GITHUB_OUTPUT
            echo "✓ Web app affected"
          else
            echo "web=false" >> $GITHUB_OUTPUT
            echo "✗ Web app not affected"
          fi
          
          if echo "$AFFECTED" | grep -qE "(^|\s)api(\s|$)"; then
            echo "api=true" >> $GITHUB_OUTPUT
            echo "✓ API app affected"
          else
            echo "api=false" >> $GITHUB_OUTPUT
            echo "✗ API app not affected"
          fi
          
          if echo "$AFFECTED" | grep -qE "(^|\s)funnel(\s|$)"; then
            echo "funnel=true" >> $GITHUB_OUTPUT
            echo "✓ Funnel app affected"
          else
            echo "funnel=false" >> $GITHUB_OUTPUT
            echo "✗ Funnel app not affected"
          fi
          
          if echo "$AFFECTED" | grep -qE "(^|\s)landing(\s|$)"; then
            echo "landing=true" >> $GITHUB_OUTPUT
            echo "✓ Landing app affected"
          else
            echo "landing=false" >> $GITHUB_OUTPUT
            echo "✗ Landing app not affected"
          fi
          
          if [ -z "$AFFECTED" ] || ! echo "$AFFECTED" | grep -qE "(^|\s)(web|api|funnel|landing)(\s|$)"; then
            echo "has-changes=false" >> $GITHUB_OUTPUT
            echo "No app changes detected"
          else
            echo "has-changes=true" >> $GITHUB_OUTPUT
            echo "App changes detected"
          fi

  deploy-web:
    name: Deploy Web App
    needs: detect-changes
    if: needs.detect-changes.outputs.web == 'true'
    runs-on: ubuntu-latest
    environment: production
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Enable corepack (for pnpm)
        run: corepack enable

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Pull and extract ghcr assets (for web app)
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
          docker pull ghcr.io/jatidevelopments/ryla-web-assets:latest || echo "Warning: Could not pull ghcr assets image, will use default public folder"
          # Extract assets from the image and copy to public folder
          if docker image inspect ghcr.io/jatidevelopments/ryla-web-assets:latest >/dev/null 2>&1; then \
            echo "========================================="; \
            echo "Extracting assets from ghcr image..."; \
            echo "========================================="; \
            CONTAINER_ID=$(docker create ghcr.io/jatidevelopments/ryla-web-assets:latest); \
            echo "Created container: $CONTAINER_ID"; \
            # List container filesystem to see what's available
            echo "Container filesystem structure:"; \
            docker run --rm ghcr.io/jatidevelopments/ryla-web-assets:latest ls -la / 2>/dev/null || true; \
            # Try multiple source paths
            EXTRACTED=false; \
            for SOURCE_PATH in "/public" "/assets" "/"; do \
              echo "Trying to extract from $SOURCE_PATH"; \
              if docker cp "$CONTAINER_ID:$SOURCE_PATH" ./apps/web/public-temp/ 2>/dev/null; then \
                echo "Successfully extracted from $SOURCE_PATH"; \
                echo "Contents of public-temp:"; \
                ls -la ./apps/web/public-temp/ | head -20 || true; \
                if [ -d "./apps/web/public-temp" ] && [ "$(ls -A ./apps/web/public-temp 2>/dev/null)" ]; then \
                  echo "Copying extracted assets to apps/web/public/"; \
                  # Ensure target directory exists
                  mkdir -p ./apps/web/public/; \
                  # Copy with verbose output
                  cp -rv ./apps/web/public-temp/* ./apps/web/public/ 2>&1 | head -30 || true; \
                  echo "Files in apps/web/public/images after copy:"; \
                  ls -la ./apps/web/public/images/ 2>/dev/null | head -20 || echo "No images directory found"; \
                  echo "Ethnicity images:"; \
                  ls -la ./apps/web/public/images/ethnicity/ 2>/dev/null | head -10 || echo "No ethnicity directory found"; \
                  EXTRACTED=true; \
                  break; \
                else \
                  echo "public-temp is empty, trying next path"; \
                fi; \
              else \
                echo "Failed to extract from $SOURCE_PATH"; \
              fi; \
              rm -rf ./apps/web/public-temp; \
            done; \
            docker rm "$CONTAINER_ID" 2>/dev/null || true; \
            if [ "$EXTRACTED" = "false" ]; then \
              echo "Warning: Could not extract assets from any path, using default public folder"; \
            else \
              echo "✅ Assets extracted successfully!"; \
            fi; \
          else \
            echo "Warning: ghcr image not found, using default public folder"; \
          fi
        continue-on-error: true

      - name: Setup Fly.io CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Stop old machines (if any)
        run: |
          # Install jq if not available
          sudo apt-get update && sudo apt-get install -y jq || true
          # Stop all machines for this app to ensure clean deployment
          MACHINES=$(flyctl machines list --app ryla-web-prod --json 2>/dev/null || echo "[]")
          echo "$MACHINES" | jq -r '.[].id' | while read machine_id; do
            if [ -n "$machine_id" ]; then
              echo "Stopping machine: $machine_id"
              flyctl machines stop "$machine_id" --app ryla-web-prod || true
            fi
          done
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        continue-on-error: true

      - name: Deploy Web App to Fly.io
        run: |
          flyctl deploy \
            --config apps/web/fly.toml \
            --dockerfile apps/web/Dockerfile \
            --app ryla-web-prod \
            --strategy immediate \
            --build-arg NEXT_PUBLIC_API_URL="${{ secrets.NEXT_PUBLIC_API_URL }}" \
            --build-arg NEXT_PUBLIC_SITE_URL="${{ secrets.NEXT_PUBLIC_SITE_URL }}" \
            --build-arg NEXT_PUBLIC_POSTHOG_KEY="${{ secrets.NEXT_PUBLIC_POSTHOG_KEY }}" \
            --build-arg NEXT_PUBLIC_POSTHOG_HOST="${{ secrets.NEXT_PUBLIC_POSTHOG_HOST }}" \
            --build-arg NEXT_PUBLIC_SUPABASE_URL="${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}" \
            --build-arg NEXT_PUBLIC_SUPABASE_ANON_KEY="${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}"
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}

      - name: Health Check
        run: |
          sleep 10
          flyctl status --app ryla-web-prod
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}

      - name: Notify Slack
        if: success()
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text":"DEPLOY: production ${{ github.ref_name }} - web app success"}' \
            ${{ secrets.SLACK_WEBHOOK_DEPLOYS || 'https://hooks.slack.com/services/PLACEHOLDER' }}
        continue-on-error: true

  deploy-api:
    name: Deploy API App
    needs: detect-changes
    if: needs.detect-changes.outputs.api == 'true'
    runs-on: ubuntu-latest
    environment: production
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Enable corepack (for pnpm)
        run: corepack enable

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Setup Fly.io CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Stop old machines (if any)
        run: |
          # Install jq if not available
          sudo apt-get update && sudo apt-get install -y jq || true
          # Stop all machines for this app to ensure clean deployment
          MACHINES=$(flyctl machines list --app ryla-api-prod --json 2>/dev/null || echo "[]")
          echo "$MACHINES" | jq -r '.[].id' | while read machine_id; do
            if [ -n "$machine_id" ]; then
              echo "Stopping machine: $machine_id"
              flyctl machines stop "$machine_id" --app ryla-api-prod || true
            fi
          done
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        continue-on-error: true

      - name: Deploy API App to Fly.io
        run: |
          flyctl deploy \
            --config apps/api/fly.toml \
            --dockerfile apps/api/Dockerfile \
            --app ryla-api-prod \
            --strategy immediate
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}

      - name: Health Check
        run: |
          sleep 10
          flyctl status --app ryla-api-prod
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}

      - name: Notify Slack
        if: success()
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text":"DEPLOY: production ${{ github.ref_name }} - api app success"}' \
            ${{ secrets.SLACK_WEBHOOK_DEPLOYS || 'https://hooks.slack.com/services/PLACEHOLDER' }}
        continue-on-error: true

  deploy-funnel:
    name: Deploy Funnel App
    needs: detect-changes
    if: needs.detect-changes.outputs.funnel == 'true'
    runs-on: ubuntu-latest
    environment: production
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Enable corepack (for pnpm)
        run: corepack enable

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Setup Fly.io CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Stop old machines (if any)
        run: |
          # Install jq if not available
          sudo apt-get update && sudo apt-get install -y jq || true
          # Stop all machines for this app to ensure clean deployment
          MACHINES=$(flyctl machines list --app ryla-funnel-prod --json 2>/dev/null || echo "[]")
          echo "$MACHINES" | jq -r '.[].id' | while read machine_id; do
            if [ -n "$machine_id" ]; then
              echo "Stopping machine: $machine_id"
              flyctl machines stop "$machine_id" --app ryla-funnel-prod || true
            fi
          done
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        continue-on-error: true

      - name: Deploy Funnel App to Fly.io
        run: |
          flyctl deploy \
            --config apps/funnel/fly.toml \
            --dockerfile apps/funnel/Dockerfile \
            --app ryla-funnel-prod \
            --strategy immediate \
            --build-arg NEXT_PUBLIC_CDN_URL="${{ secrets.NEXT_PUBLIC_CDN_URL }}" \
            --build-arg NEXT_PUBLIC_DEBUG_CDN="${{ secrets.NEXT_PUBLIC_DEBUG_CDN }}" \
            --build-arg NEXT_PUBLIC_SITE_URL="${{ secrets.NEXT_PUBLIC_SITE_URL_FUNNEL }}" \
            --build-arg NEXT_PUBLIC_API_BASE_URL="${{ secrets.NEXT_PUBLIC_API_BASE_URL }}" \
            --build-arg NEXT_PUBLIC_FINBY_PAYMENT_REDIRECT="${{ secrets.NEXT_PUBLIC_FINBY_PAYMENT_REDIRECT }}" \
            --build-arg NEXT_PUBLIC_POSTHOG_HOST="${{ secrets.NEXT_PUBLIC_POSTHOG_HOST }}" \
            --build-arg NEXT_PUBLIC_POSTHOG_KEY="${{ secrets.NEXT_PUBLIC_POSTHOG_KEY }}" \
            --build-arg NEXT_PUBLIC_SUPABASE_URL="${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}" \
            --build-arg NEXT_PUBLIC_SUPABASE_ANON_KEY="${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}"
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}

      - name: Health Check
        run: |
          sleep 10
          flyctl status --app ryla-funnel-prod
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}

      - name: Notify Slack
        if: success()
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text":"DEPLOY: production ${{ github.ref_name }} - funnel app success"}' \
            ${{ secrets.SLACK_WEBHOOK_DEPLOYS || 'https://hooks.slack.com/services/PLACEHOLDER' }}
        continue-on-error: true

  deploy-landing:
    name: Deploy Landing App
    needs: detect-changes
    if: needs.detect-changes.outputs.landing == 'true'
    runs-on: ubuntu-latest
    environment: production
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Enable corepack (for pnpm)
        run: corepack enable

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Setup Fly.io CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Stop old machines (if any)
        run: |
          # Install jq if not available
          sudo apt-get update && sudo apt-get install -y jq || true
          # Stop all machines for this app to ensure clean deployment
          MACHINES=$(flyctl machines list --app ryla-landing-prod --json 2>/dev/null || echo "[]")
          echo "$MACHINES" | jq -r '.[].id' | while read machine_id; do
            if [ -n "$machine_id" ]; then
              echo "Stopping machine: $machine_id"
              flyctl machines stop "$machine_id" --app ryla-landing-prod || true
            fi
          done
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        continue-on-error: true

      - name: Deploy Landing App to Fly.io
        run: |
          flyctl deploy \
            --config apps/landing/fly.toml \
            --dockerfile apps/landing/Dockerfile \
            --app ryla-landing-prod \
            --strategy immediate \
            --build-arg NEXT_PUBLIC_SITE_URL="${{ secrets.NEXT_PUBLIC_SITE_URL_LANDING }}" \
            --build-arg NEXT_PUBLIC_CDN_URL="${{ secrets.NEXT_PUBLIC_CDN_URL }}" \
            --build-arg NEXT_PUBLIC_DEBUG_CDN="${{ secrets.NEXT_PUBLIC_DEBUG_CDN }}"
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}

      - name: Health Check
        run: |
          sleep 10
          flyctl status --app ryla-landing-prod
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}

      - name: Notify Slack
        if: success()
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text":"DEPLOY: production ${{ github.ref_name }} - landing app success"}' \
            ${{ secrets.SLACK_WEBHOOK_DEPLOYS || 'https://hooks.slack.com/services/PLACEHOLDER' }}
        continue-on-error: true
